{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "view-in-github",
        "colab_type": "text"
      },
      "source": [
        "<a href=\"https://colab.research.google.com/github/6ftJatt/Chess-game-vs-AI/blob/main/Chess_ai\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "NM8b9KVYsETT"
      },
      "source": [
        "\n",
        "\n",
        "\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 1,
      "metadata": {
        "id": "f9apbZGptej6"
      },
      "outputs": [],
      "source": [
        "\n",
        "import random\n",
        "import time\n",
        "from IPython.display import clear_output\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 2,
      "metadata": {
        "id": "YdPwgSBOtb1P"
      },
      "outputs": [],
      "source": [
        "\n",
        "def ChessBoardSetup():\n",
        " \n",
        "    # k/K for king\n",
        "    board = [[],[],[],[],[],[],[],[]]\n",
        "    board[0] = ['r','t','b','q','k','b','t','r']\n",
        "    board[1] = ['p','p','p','p','p','p','p','p']\n",
        "    board[2] = ['.','.','.','.','.','.','.','.']\n",
        "    board[3] = ['.','.','.','.','.','.','.','.']\n",
        "    board[4] = ['.','.','.','.','.','.','.','.']\n",
        "    board[5] = ['.','.','.','.','.','.','.','.']\n",
        "    board[6] = ['P','P','P','P','P','P','P','P']\n",
        "    board[7] = ['R','T','B','Q','K','B','T','R']\n",
        "    return board\n",
        "\n",
        "def DrawBoard(board):\n",
        "\n",
        "    for row in board:\n",
        "        for col in row:\n",
        "            print(col,end=\" \")\n",
        "        print()\n",
        "\n",
        "def MovePiece(board, move):\n",
        "  \n",
        "    fr_sq = move[0] \n",
        "    to_sq = move[1]\n",
        "    board[to_sq[0]][to_sq[1]] = board[fr_sq[0]][fr_sq[1]]\n",
        "    board[fr_sq[0]][fr_sq[1]] = '.'\n",
        "    return board\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 3,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "VOmtUYPreEqN",
        "outputId": "b2ce170b-ec2c-4367-8904-f474c84c5b80"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "r t b q k b t r \n",
            "p p p p p p p p \n",
            ". . . . . . . . \n",
            ". . . . . . . . \n",
            ". . . . . . . . \n",
            ". . . . . . . . \n",
            "P P P P P P P P \n",
            "R T B Q K B T R \n",
            "\n",
            "Moving piece (1,2),(2,2)\n",
            "r t b q k b t r \n",
            "p p . p p p p p \n",
            ". . p . . . . . \n",
            ". . . . . . . . \n",
            ". . . . . . . . \n",
            ". . . . . . . . \n",
            "P P P P P P P P \n",
            "R T B Q K B T R \n"
          ]
        }
      ],
      "source": [
        "\n",
        "board = ChessBoardSetup()\n",
        "DrawBoard(board)\n",
        "print(\"\\nMoving piece (1,2),(2,2)\")\n",
        "move = ((1,2),(2,2))\n",
        "board = MovePiece(board, move)\n",
        "DrawBoard(board)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 4,
      "metadata": {
        "id": "fbBNakSDq0Wv"
      },
      "outputs": [],
      "source": [
        " \n",
        "def IsMoveLegal(board,player,fromSquare,toSquare):\n",
        "    fromSquare_r = fromSquare[0]\n",
        "    fromSquare_c = fromSquare[1]\n",
        "    toSquare_r = toSquare[0]\n",
        "    toSquare_c = toSquare[1]\n",
        "    fromPiece = board[fromSquare_r][fromSquare_c]\n",
        "    toPiece = board[toSquare_r][toSquare_c]\n",
        "\n",
        "    if fromSquare == toSquare:\n",
        "        return False\n",
        "    \n",
        "\n",
        "    if(fromPiece.lower() == 'k'):\n",
        "       \n",
        "        col_diff = toSquare_c - fromSquare_c\n",
        "        \n",
        "        row_diff = toSquare_r - fromSquare_r\n",
        "       \n",
        "        if (toPiece == '.' or ((player == \"black\" and toPiece.isupper()) or (player == \"white\" and toPiece.islower()))):    \n",
        "        \n",
        "            if(abs(col_diff) == 1 and abs(row_diff == 0)):\n",
        "                return True\n",
        "            \n",
        "            if(abs(col_diff) == 0 and abs(row_diff == 1)):\n",
        "                return True\n",
        "           \n",
        "            if(abs(col_diff) == 1 and abs(row_diff == 1)):\n",
        "                return True\n",
        "\n",
        "    \n",
        "    elif(fromPiece.lower() == 'r'):\n",
        "        \n",
        "        if (toSquare_r == fromSquare_r or toSquare_c == fromSquare_c):\n",
        "            if (toPiece == '.' or ((player == \"black\" and toPiece.isupper()) or (player == \"white\" and toPiece.islower()))):\n",
        "                \n",
        "                if IsClearPath(board,fromSquare,toSquare):\n",
        "                   \n",
        "                    return True\n",
        "\n",
        "  \n",
        "    elif(fromPiece.lower() == 'b'):\n",
        "       \n",
        "        col_diff = toSquare_c - fromSquare_c\n",
        "        row_diff = toSquare_r - fromSquare_r\n",
        "        if(abs(col_diff) == abs(row_diff)):\n",
        "         \n",
        "            if (toPiece == '.' or ((player == \"black\" and toPiece.isupper()) or (player == \"white\" and toPiece.islower()))):\n",
        "      \n",
        "                if IsClearPath(board,fromSquare,toSquare):\n",
        "                   \n",
        "                    return True\n",
        "\n",
        "    \n",
        "    elif(fromPiece.lower() == 'q'):\n",
        "        \n",
        "        if (toSquare_r == fromSquare_r or toSquare_c == fromSquare_c):\n",
        "            \n",
        "            if (toPiece == '.' or ((player == \"black\" and toPiece.isupper()) or (player == \"white\" and toPiece.islower()))):\n",
        "\n",
        "                if IsClearPath(board,fromSquare,toSquare):\n",
        "                    \n",
        "                    return True\n",
        "   \n",
        "        col_diff = toSquare_c - fromSquare_c\n",
        "        row_diff = toSquare_r - fromSquare_r\n",
        "        if(abs(col_diff) == abs(row_diff)):\n",
        "           \n",
        "            if (toPiece == '.' or ((player == \"black\" and toPiece.isupper()) or (player == \"white\" and toPiece.islower()))):\n",
        "               \n",
        "                if IsClearPath(board,fromSquare,toSquare):\n",
        "                   \n",
        "                    return True\n",
        "\n",
        "    \n",
        "    elif(fromPiece.lower() == 't'):\n",
        "        \n",
        "        col_diff = toSquare_c - fromSquare_c\n",
        "        \n",
        "        row_diff = toSquare_r - fromSquare_r\n",
        "        \n",
        "        if (toPiece == '.' or ((player == \"black\" and toPiece.isupper()) or (player == \"white\" and toPiece.islower()))):\n",
        "            \n",
        "                if(col_diff == 1 and row_diff == -2):\n",
        "                    return True\n",
        "               \n",
        "                if(col_diff == 2  and row_diff == -1):\n",
        "                    return True\n",
        "               \n",
        "                if(col_diff == 2  and row_diff ==  1):\n",
        "                    return True\n",
        "                \n",
        "                if(col_diff == 1  and row_diff ==  2):\n",
        "                    return True\n",
        "              \n",
        "                if(col_diff == -1 and row_diff == -2):\n",
        "                    return True\n",
        "              \n",
        "                if(col_diff == -2 and row_diff == -1):\n",
        "                    return True\n",
        "                \n",
        "                if(col_diff == -2 and row_diff ==  1):\n",
        "                    return True\n",
        "              \n",
        "                if(col_diff == -1 and row_diff ==  2):\n",
        "                    return True\n",
        "\n",
        "    elif(fromPiece.lower() == 'p'):\n",
        "     \n",
        "        col_diff = toSquare_c - fromSquare_c\n",
        "        \n",
        "        row_diff = toSquare_r - fromSquare_r\n",
        "        \n",
        "       \n",
        "        if ( toPiece == '.' and ((player==\"black\" and toSquare_c == fromSquare_c and row_diff == 1 ) or (player==\"white\" and toSquare_c == fromSquare_c and row_diff == -1 ))):\n",
        "          \n",
        "            return True\n",
        "     \n",
        "        elif(toPiece == '.' and ( (player == \"black\" and fromSquare_r == 1 and fromSquare_c == toSquare_c and toSquare_r == fromSquare_r + 2) or (player == \"white\" and fromSquare_r == 6 and fromSquare_c == toSquare_c and toSquare_r == fromSquare_r - 2) ) ):\n",
        "            \n",
        "            if IsClearPath(board,fromSquare,toSquare):\n",
        "              \n",
        "                return True\n",
        "       \n",
        "        elif( ( (player == \"black\" and fromPiece.isupper() and toPiece.isupper() and row_diff == 1) or (player == \"white\" and fromPiece.isupper() and toPiece.islower() and row_diff == -1) ) and abs(col_diff) == 1 ):\n",
        "            \n",
        "            return True\n",
        "\n",
        "   \n",
        "    return False\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "def GetListOfLegalMoves(board, player, piece):\n",
        "\n",
        "    to_squares = []\n",
        "    \n",
        "    for i in range(len(board)):\n",
        "       \n",
        "        for j in range(len(board[0])):\n",
        "            to_square = (i,j)\n",
        "            \n",
        "            legal = IsMoveLegal(board, player, piece, to_square)\n",
        "            \n",
        "            if (legal):\n",
        "         \n",
        "                check = DoesMovePutPlayerInCheck(board, player, piece, to_square)\n",
        "                \n",
        "                if (not check):\n",
        "                    \n",
        "                    to_squares.append(to_square)\n",
        "    \n",
        "    return to_squares\n",
        "\n",
        "\n",
        "\n",
        "def GetPiecesWithLegalMoves(board, player):\n",
        "    \n",
        "    pieces = []\n",
        "    squares = []\n",
        "    for i in range(len(board)):\n",
        "        \n",
        "        for j in range(len(board[0])):\n",
        "            square = board[i][j]\n",
        "            from_square = (i,j)\n",
        "           \n",
        "            if( (player == \"white\" and square.isupper()) or (player == \"black\" and square.islower()) ):\n",
        "               \n",
        "                moves = GetListOfLegalMoves(board, player, from_square)\n",
        "               \n",
        "                if (moves):\n",
        "                   \n",
        "                    pieces.append(square)\n",
        "                    squares.append(from_square)\n",
        "\n",
        "    return squares\n",
        "\n",
        "\n",
        "\n",
        "def IsCheckmate(board, player):\n",
        "    \n",
        "    pieces = GetPiecesWithLegalMoves(board, player)\n",
        "    \n",
        "    if (not pieces):\n",
        "        \n",
        "        return True\n",
        "    \n",
        "    else:\n",
        "        \n",
        "        return False\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "def IsInCheck(board, player):\n",
        "  \n",
        "    king_row = 0\n",
        "    king_column = 0\n",
        "    found = False\n",
        "    for i in range(len(board)):\n",
        "        for j in range(len(board[0])):\n",
        "            if( (player==\"black\" and board[i][j]==\"k\") or (player==\"white\" and board[i][j]==\"K\") ):\n",
        "                king_row = i\n",
        "                king_column = j\n",
        "    king_square = (king_row, king_column)\n",
        "   \n",
        "    for i in range(len(board)):\n",
        "        for j in range(len(board[0])):\n",
        "          \n",
        "            if( (player==\"black\" and board[i][j].isupper()) or (player==\"white\" and board[i][j].islower()) ):\n",
        "                enemy_square = (i, j)\n",
        "                \n",
        "                legal = IsMoveLegal(board,player,enemy_square,king_square)\n",
        "                \n",
        "                if(legal):    \n",
        "                   \n",
        "                    return True\n",
        "                \n",
        "                else:\n",
        "                   \n",
        "                    continue\n",
        "   \n",
        "    return False\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "def IsClearPath(board,fromSquare,toSquare):\n",
        "    fromSquare_r = fromSquare[0]\n",
        "    fromSquare_c = fromSquare[1]\n",
        "    toSquare_r = toSquare[0]\n",
        "    toSquare_c = toSquare[1]\n",
        "    fromPiece = board[fromSquare_r][fromSquare_c]\n",
        "\n",
        "   \n",
        "    if abs(fromSquare_r - toSquare_r) <= 1 and abs(fromSquare_c - toSquare_c) <= 1:\n",
        "        \n",
        "        return True\n",
        "    else:\n",
        "   \n",
        "        if toSquare_r > fromSquare_r and toSquare_c == fromSquare_c:\n",
        "            \n",
        "            newSquare = (fromSquare_r+1,fromSquare_c)\n",
        "        \n",
        "        elif toSquare_r < fromSquare_r and toSquare_c == fromSquare_c:\n",
        "            \n",
        "            newSquare = (fromSquare_r-1,fromSquare_c)\n",
        "      \n",
        "        elif toSquare_c > fromSquare_c and toSquare_r == fromSquare_r:\n",
        "          \n",
        "            newSquare = (fromSquare_r,fromSquare_c+1)\n",
        "        \n",
        "        elif toSquare_c < fromSquare_c and toSquare_r == fromSquare_r:\n",
        "          \n",
        "            newSquare = (fromSquare_r,fromSquare_c-1)\n",
        "      \n",
        "        elif toSquare_r > fromSquare_r and toSquare_c > fromSquare_c:\n",
        "          \n",
        "            newSquare = (fromSquare_r+1,fromSquare_c+1)\n",
        "        \n",
        "        elif toSquare_r > fromSquare_r and toSquare_c < fromSquare_c:\n",
        "          \n",
        "            newSquare = (fromSquare_r+1,fromSquare_c-1)\n",
        "      \n",
        "        elif toSquare_r < fromSquare_r and toSquare_c > fromSquare_c:\n",
        "           \n",
        "            newSquare = (fromSquare_r-1,fromSquare_c+1)\n",
        "        \n",
        "        elif toSquare_r < fromSquare_r and toSquare_c < fromSquare_c:\n",
        "         \n",
        "            newSquare = (fromSquare_r-1,fromSquare_c-1)\n",
        "\n",
        "\n",
        "    newSquarePiece = board[newSquare[0]][newSquare[1]]\n",
        "    if(newSquarePiece != '.'):\n",
        "        \n",
        "        return False\n",
        "    \n",
        "    else:\n",
        "     \n",
        "        return IsClearPath(board,newSquare,toSquare)\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "def DoesMovePutPlayerInCheck(board, player, from_square, to_square):\n",
        "\n",
        "    fromPiece = board[from_square[0]][from_square[1]]\n",
        "    toPiece = board[to_square[0]][to_square[1]]\n",
        "    \n",
        "    move = (from_square, to_square)\n",
        "    board = MovePiece(board, move)\n",
        "\n",
        "    inCheck = IsInCheck(board, player)\n",
        "    \n",
        "    board[from_square[0]][from_square[1]] = fromPiece\n",
        "    board[to_square[0]][to_square[1]] = toPiece\n",
        "    \n",
        "    return inCheck\n",
        "\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 5,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "qL1Jwjg8eEqY",
        "outputId": "0bf8ef31-1aa2-4aaf-f694-fe688e46c200"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "r t b q k b t r \n",
            "p p p p p p p p \n",
            ". . . . . . . . \n",
            ". . . . . . . . \n",
            ". . . . . . . . \n",
            ". . . . . . . . \n",
            "P P P P P P P P \n",
            "R T B Q K B T R \n",
            "True\n",
            "[(5, 5), (5, 7)]\n",
            "[(6, 0), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6), (6, 7), (7, 1), (7, 6)]\n",
            "False\n",
            "False\n",
            "False\n",
            "False\n"
          ]
        }
      ],
      "source": [
        "\n",
        "board = ChessBoardSetup()\n",
        "player = \"white\"\n",
        "fromSquare = (7,6)\n",
        "toSquare = (5,5)\n",
        "DrawBoard(board)\n",
        "print(IsMoveLegal(board,player,fromSquare,toSquare))\n",
        "print(GetListOfLegalMoves(board, player, fromSquare))\n",
        "print(GetPiecesWithLegalMoves(board, player))\n",
        "print(IsCheckmate(board, player))\n",
        "print(IsInCheck(board, player))\n",
        "print(IsClearPath(board,fromSquare,toSquare))\n",
        "print(DoesMovePutPlayerInCheck(board, player, fromSquare, toSquare))"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 6,
      "metadata": {
        "id": "XELGzRDftS77"
      },
      "outputs": [],
      "source": [
        "def GetRandomMove(board, player):\n",
        "  \n",
        "    pieces = GetPiecesWithLegalMoves(board, player)\n",
        "    fromSquare = random.choice(pieces)\n",
        "    moves = GetListOfLegalMoves(board, player, fromSquare)\n",
        "    move = random.choice(moves)\n",
        "    return (fromSquare, move)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 7,
      "metadata": {
        "id": "FYSK99zp5a7H"
      },
      "outputs": [],
      "source": [
        "def numberOfPiece(board, piece):\n",
        "    c = 0\n",
        "    for row in board:\n",
        "        for square in row:\n",
        "            if(square == piece):\n",
        "                c = c + 1\n",
        "    return c\n",
        "\n",
        "\n",
        "def evl(board, player):\n",
        "    \n",
        "    res = 0\n",
        "    \n",
        "    res += 1 * numberOfPiece(board, 'P') + 3 * (numberOfPiece(board, 'T') + numberOfPiece(board, 'B')) + 5 * numberOfPiece(board, 'R') + 9 * numberOfPiece(board, 'Q')\n",
        "    res += - 1 * numberOfPiece(board, 'p') - 3 * (numberOfPiece(board, 't') + numberOfPiece(board, 'b')) - 5 * numberOfPiece(board, 'r') - 9 * numberOfPiece(board, 'q')\n",
        "    if(player == \"black\"):\n",
        "        return -1 * res\n",
        "    else:\n",
        "        return res\n",
        "\n",
        "def GetMinMaxMove(board, curPlayer):\n",
        "    \n",
        "    enemyPlayer = \"\"\n",
        "    if(curPlayer == \"white\"):\n",
        "        enemyPlayer = \"black\"\n",
        "    else:\n",
        "        enemyPlayer = \"white\"\n",
        "    \n",
        "    \n",
        "    bestMove = False\n",
        "\n",
        "    pieces = GetPiecesWithLegalMoves(board, curPlayer)\n",
        "  \n",
        "    maximum = -1000000\n",
        "    alpha = -1000000\n",
        "    pruneMax = False\n",
        "    for piece in pieces:\n",
        "     \n",
        "        moves = GetListOfLegalMoves(board, curPlayer, piece)\n",
        "        \n",
        "        for move in moves:\n",
        "            \n",
        "            move = (piece, move)\n",
        "          \n",
        "            fromPiece = board[move[0][0]][move[0][1]]\n",
        "            toPiece = board[move[1][0]][move[1][1]]\n",
        "           \n",
        "            board = MovePiece(board, move)    \n",
        "         \n",
        "            enemyPieces = GetPiecesWithLegalMoves(board, enemyPlayer)\n",
        "         \n",
        "            minimum = 1000000\n",
        "            beta = 1000000\n",
        "            pruneMin = False\n",
        "            for enemyPiece in enemyPieces:\n",
        "              \n",
        "                enemyMoves = GetListOfLegalMoves(board, enemyPlayer, enemyPiece)\n",
        "              \n",
        "                for enemyMove in enemyMoves:\n",
        "                    \n",
        "                    enemyMove = (enemyPiece, enemyMove)\n",
        "                    fromPieceEnemy = board[enemyMove[0][0]][enemyMove[0][1]]\n",
        "                    toPieceEnemy = board[enemyMove[1][0]][enemyMove[1][1]]\n",
        "                  \n",
        "                    res = evl(board, curPlayer)\n",
        "                   \n",
        "                    if(res <= minimum):\n",
        "                        minimum = res\n",
        "                        bestEnemyMove = enemyMove\n",
        "                        beta = min(beta, minimum)\n",
        "                    \n",
        "                    board[enemyMove[0][0]][enemyMove[0][1]] = fromPieceEnemy\n",
        "                    board[enemyMove[1][0]][enemyMove[1][1]] = toPieceEnemy\n",
        "                    if(minimum <= alpha):\n",
        "                        pruneMin = True\n",
        "                        break\n",
        "                if(pruneMin):\n",
        "                    break\n",
        "            \n",
        "            if(minimum >= maximum):\n",
        "                maximum = minimum\n",
        "                bestMove = move\n",
        "                alpha = max(alpha, maximum)\n",
        "            \n",
        "            board[move[0][0]][move[0][1]] = fromPiece\n",
        "            board[move[1][0]][move[1][1]] = toPiece\n",
        "            \"\"\"\n",
        "            if(maximum >= beta):\n",
        "                pruneMax = True\n",
        "                break\n",
        "        if(pruneMax):\n",
        "            break\n",
        "        \"\"\"\n",
        "    \n",
        "    move = bestMove\n",
        "    \n",
        "    if(not bestMove):\n",
        "        move = GetRandomMove(board, curPlayer)\n",
        "\n",
        "    \n",
        "    return move\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 8,
      "metadata": {
        "id": "oYcy29SdK3Xn",
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "outputId": "dfd6a7eb-6b13-4290-b787-6aa2b5231222"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            ". . . . . . . . \n",
            ". . . . . . k Q \n",
            ". . . . . . . . \n",
            ". . . . R . . . \n",
            ". . . . . . . . \n",
            "T . P P . . . P \n",
            "P P P . . P B P \n",
            "R . B . . . K . \n",
            "\n",
            "WHITE / MinMaxAI plays!\n",
            "\n",
            ". . . . . . . . \n",
            ". . . . . . Q . \n",
            ". . . . . . . . \n",
            ". . . . R . . . \n",
            ". . . . . . . . \n",
            "T . P P . . . P \n",
            "P P P . . P B P \n",
            "R . B . . . K . \n",
            "CHECKMATE!\n",
            "MinMaxAI - WHITE - uppercase won the game in 31 turns!\n"
          ]
        }
      ],
      "source": [
        "\n",
        "board = ChessBoardSetup()\n",
        "player1Type = 'minmaxAI'\n",
        "player1player = 'white'\n",
        "player2Type = 'randomAI'\n",
        "player2player = 'black'\n",
        "\n",
        "currentPlayerIndex = 0\n",
        "currentplayer = 'white'\n",
        "turns = 0\n",
        "N = 100\n",
        "\n",
        "\n",
        "while not IsCheckmate(board,currentplayer) and turns < N:\n",
        "    clear_output()\n",
        "    DrawBoard(board)\n",
        "\n",
        "\n",
        "    if currentplayer == 'black':\n",
        "        move = GetRandomMove(board, currentplayer)\n",
        "        print(\"\\nBLACK / RandomAI plays!\\n\")\n",
        "    else:\n",
        "        turns = turns + 1\n",
        "        move = GetMinMaxMove(board, currentplayer)\n",
        "        print(\"\\nWHITE / MinMaxAI plays!\\n\")\n",
        "    \n",
        "    board = MovePiece(board,move)\n",
        "    currentPlayerIndex = (currentPlayerIndex+1)%2\n",
        "    currentplayer = 'black' if currentplayer == 'white' else 'white'\n",
        "\n",
        "    DrawBoard(board)\n",
        "    time.sleep(0.5)\n",
        "\n",
        "if(IsCheckmate(board,currentplayer)):\n",
        "    print(\"CHECKMATE!\")\n",
        "    winnerIndex = (currentPlayerIndex+1)%2\n",
        "    if(winnerIndex == 0):\n",
        "        print(\"MinMaxAI - WHITE - uppercase won the game in \" + str(turns) + \" turns!\")\n",
        "    else:\n",
        "        print(\"RandomAI - BLACK - lowercase won the game in \" + str(turns) + \" turns!\")\n",
        "else:\n",
        "    print(\"STALEMATE!\")\n",
        "    "
      ]
    }
  ],
  "metadata": {
    "colab": {
      "provenance": [],
      "include_colab_link": true
    },
    "kernelspec": {
      "display_name": "Python 3 (ipykernel)",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.8.10"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}